/*
 * generated by Xtext 2.20.0
 */
package uk.ac.kcl.mde.gawk.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.mde.gawk.gawk.GawkProgram
import uk.ac.kcl.mde.gawk.gawk.SectionHeader
import uk.ac.kcl.mde.gawk.gawk.Statement
import uk.ac.kcl.mde.gawk.gawk.MatchStatement
import uk.ac.kcl.mde.gawk.gawk.VariableDeclaration
import uk.ac.kcl.mde.gawk.gawk.PrintStatement
import org.eclipse.emf.common.util.EList
import uk.ac.kcl.mde.gawk.gawk.PrintOptions
import uk.ac.kcl.mde.gawk.gawk.StringOption
import uk.ac.kcl.mde.gawk.gawk.ColOption
import uk.ac.kcl.mde.gawk.gawk.VarReference
import uk.ac.kcl.mde.gawk.gawk.MatchDeclaration
import uk.ac.kcl.mde.gawk.gawk.IntOption
import uk.ac.kcl.mde.gawk.gawk.VariableOptions
import uk.ac.kcl.mde.gawk.gawk.Section

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class GawkGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as GawkProgram
		
		fsa.generateFile('program.txt', model.doGenerateProgram)
	}
	
	def String doGenerateProgram(GawkProgram program) '''
		//YOUR AWK PROGRAM
		awk '«program.sections.generateSections(SectionHeader.START)»«program.sections.generateSections(SectionHeader.BODY)»«program.sections.generateSections(SectionHeader.END)»' «program.filename.file.generateAwkMatchExp»
	'''
	
	def generateSections(EList<Section> sections, SectionHeader headerType) {
		val sectionIterable = sections.filter[sectionBlock | sectionBlock.section == headerType]
		sectionIterable.map[section | 
			if (section.statements.length > 0) {
				if (headerType == SectionHeader.START) {
					'''BEGIN {«section.statements.generateAwkCommandsForSection»}'''	
				} else if (headerType == SectionHeader.BODY) {
					'''«section.statements.generateAwkCommandsForSection»'''
				} else {
					'''END {«section.statements.generateAwkCommandsForSection»}'''
				}
			}
		].join(' ')
	}
	
	def generateAwkCommandsForSection(EList<Statement> stmts) {
		'''«stmts.map[generateAwkCommand].join(' ')»'''
	}
	
	dispatch def generateAwkCommand(Statement stmt) ''''''
	dispatch def generateAwkCommand(MatchStatement stmt) '''/«stmt.exp.generateAwkMatchExp»/'''
	dispatch def generateAwkCommand(VariableDeclaration stmt) '''«stmt.name» = «stmt.^val.generateAwkVariableOptions»;'''
	dispatch def generateAwkCommand(PrintStatement stmt) '''{print «stmt.options.map[generateAwkPrintOption].join(' ')»}'''
	
	dispatch def generateAwkPrintOption(PrintOptions opt) ''''''
	dispatch def generateAwkPrintOption(StringOption opt) '''"«opt.^val»"'''
	dispatch def generateAwkPrintOption(ColOption opt) '''$«opt.^val.columnIndex»'''
	dispatch def generateAwkPrintOption(VarReference opt) '''«opt.^val.generateAwkVarDeclaration»'''
	
	dispatch def generateAwkMatchExp(MatchDeclaration decl) ''''''
	dispatch def generateAwkMatchExp(StringOption decl) '''«decl.^val»'''
	dispatch def generateAwkMatchExp(VarReference decl) '''«decl.^val.generateAwkVarDeclaration»'''
	
	dispatch def generateAwkVariableOptions(VariableOptions decl) ''''''
	dispatch def generateAwkVariableOptions(StringOption decl) '''"«decl.^val»"'''
	dispatch def generateAwkVariableOptions(IntOption decl) '''«decl.^val»'''
	
	def generateAwkVarDeclaration(VariableDeclaration opt) '''«opt.^val.generateAwkVariableOptions»'''

}
